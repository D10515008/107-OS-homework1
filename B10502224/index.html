<!DOCTYPE html>

<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="mobile-web-app-capable" content="yes">
    <title>
        B10502224 古智斌 OS　HW1 - HackMD
    </title>
    <link rel="icon" type="image/png" href="https://hackmd.io/favicon.png">
    <link rel="apple-touch-icon" href="https://hackmd.io/apple-touch-icon.png">

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha256-916EbMg70RQy9LHiGkXzG8hSg9EdNy97GazNG/aiY1w=" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha256-eZrrJcwDc/3uDhsdt61sL2oOBY362qM3lon1gyExkL0=" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/ionicons/2.0.1/css/ionicons.min.css" integrity="sha256-3iu9jgsy9TpTwXKb7bNQzqWekRX7pPK+2OLj3R922fo=" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/octicons/3.5.0/octicons.min.css" integrity="sha256-QiWfLIsCT02Sdwkogf6YMiQlj4NE84MKkzEMkZnMGdg=" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.1/themes/prism.min.css" integrity="sha256-vtR0hSWRc3Tb26iuN2oZHt3KRUomwTufNIf5/4oeCyg=" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/emojify.js/1.1.0/css/basic/emojify.min.css" integrity="sha256-UOrvMOsSDSrW6szVLe8ZDZezBxh5IoIfgTwdNDgTjiU=" crossorigin="anonymous" />
    <style>
        @import url(https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,500,500i|Source+Code+Pro:300,400,500|Source+Sans+Pro:300,300i,400,400i,600,600i|Source+Serif+Pro&subset=latin-ext);.hljs{display:block;background:#fff;padding:.5em;color:#333;overflow-x:auto}.hljs-comment,.hljs-meta{color:#969896}.hljs-emphasis,.hljs-quote,.hljs-string,.hljs-strong,.hljs-template-variable,.hljs-variable{color:#df5000}.hljs-keyword,.hljs-selector-tag,.hljs-type{color:#a71d5d}.hljs-attribute,.hljs-bullet,.hljs-literal,.hljs-number,.hljs-symbol{color:#0086b3}.hljs-built_in,.hljs-builtin-name{color:#005cc5}.hljs-name,.hljs-section{color:#63a35c}.hljs-tag{color:#333}.hljs-attr,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-id,.hljs-selector-pseudo,.hljs-title{color:#795da3}.hljs-addition{color:#55a532;background-color:#eaffea}.hljs-deletion{color:#bd2c00;background-color:#ffecec}.hljs-link{text-decoration:underline}.markdown-body{font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,sans-serif;font-size:16px;line-height:1.5;word-wrap:break-word}.markdown-body:after,.markdown-body:before{display:table;content:""}.markdown-body:after{clear:both}.markdown-body>:first-child{margin-top:0!important}.markdown-body>:last-child{margin-bottom:0!important}.markdown-body a:not([href]){color:inherit;text-decoration:none}.markdown-body .absent{color:#c00}.markdown-body .anchor{float:left;padding-right:4px;margin-left:-20px;line-height:1}.markdown-body .anchor:focus{outline:none}.markdown-body blockquote,.markdown-body dl,.markdown-body ol,.markdown-body p,.markdown-body pre,.markdown-body table,.markdown-body ul{margin-top:0;margin-bottom:16px}.markdown-body hr{height:.25em;padding:0;margin:24px 0;background-color:#e7e7e7;border:0}.markdown-body blockquote{font-size:16px;padding:0 1em;color:#777;border-left:.25em solid #ddd}.markdown-body blockquote>:first-child{margin-top:0}.markdown-body blockquote>:last-child{margin-bottom:0}.markdown-body .loweralpha{list-style-type:lower-alpha}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{margin-top:24px;margin-bottom:16px;font-weight:600;line-height:1.25}.markdown-body h1 .octicon-link,.markdown-body h2 .octicon-link,.markdown-body h3 .octicon-link,.markdown-body h4 .octicon-link,.markdown-body h5 .octicon-link,.markdown-body h6 .octicon-link{color:#000;vertical-align:middle;visibility:hidden}.markdown-body h1:hover .anchor,.markdown-body h2:hover .anchor,.markdown-body h3:hover .anchor,.markdown-body h4:hover .anchor,.markdown-body h5:hover .anchor,.markdown-body h6:hover .anchor{text-decoration:none}.markdown-body h1:hover .anchor .octicon-link,.markdown-body h2:hover .anchor .octicon-link,.markdown-body h3:hover .anchor .octicon-link,.markdown-body h4:hover .anchor .octicon-link,.markdown-body h5:hover .anchor .octicon-link,.markdown-body h6:hover .anchor .octicon-link{visibility:visible}.markdown-body h1 code,.markdown-body h1 tt,.markdown-body h2 code,.markdown-body h2 tt,.markdown-body h3 code,.markdown-body h3 tt,.markdown-body h4 code,.markdown-body h4 tt,.markdown-body h5 code,.markdown-body h5 tt,.markdown-body h6 code,.markdown-body h6 tt{font-size:inherit}.markdown-body h1{font-size:2em}.markdown-body h1,.markdown-body h2{padding-bottom:.3em;border-bottom:1px solid #eee}.markdown-body h2{font-size:1.5em}.markdown-body h3{font-size:1.25em}.markdown-body h4{font-size:1em}.markdown-body h5{font-size:.875em}.markdown-body h6{font-size:.85em;color:#777}.markdown-body ol,.markdown-body ul{padding-left:2em}.markdown-body ol.no-list,.markdown-body ul.no-list{padding:0;list-style-type:none}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:0;margin-bottom:0}.markdown-body li>p{margin-top:16px}.markdown-body li+li{margin-top:.25em}.markdown-body dl{padding:0}.markdown-body dl dt{padding:0;margin-top:16px;font-size:1em;font-style:italic;font-weight:700}.markdown-body dl dd{padding:0 16px;margin-bottom:16px}.markdown-body table{display:block;width:100%;overflow:auto;word-break:normal;word-break:keep-all}.markdown-body table th{font-weight:700}.markdown-body table td,.markdown-body table th{padding:6px 13px;border:1px solid #ddd}.markdown-body table tr{background-color:#fff;border-top:1px solid #ccc}.markdown-body table tr:nth-child(2n){background-color:#f8f8f8}.markdown-body img{max-width:100%;box-sizing:content-box;background-color:#fff}.markdown-body img[align=right]{padding-left:20px}.markdown-body img[align=left]{padding-right:20px}.markdown-body .emoji{max-width:none;vertical-align:text-top;background-color:transparent}.markdown-body span.frame{display:block;overflow:hidden}.markdown-body span.frame>span{display:block;float:left;width:auto;padding:7px;margin:13px 0 0;overflow:hidden;border:1px solid #ddd}.markdown-body span.frame span img{display:block;float:left}.markdown-body span.frame span span{display:block;padding:5px 0 0;clear:both;color:#333}.markdown-body span.align-center{display:block;overflow:hidden;clear:both}.markdown-body span.align-center>span{display:block;margin:13px auto 0;overflow:hidden;text-align:center}.markdown-body span.align-center span img{margin:0 auto;text-align:center}.markdown-body span.align-right{display:block;overflow:hidden;clear:both}.markdown-body span.align-right>span{display:block;margin:13px 0 0;overflow:hidden;text-align:right}.markdown-body span.align-right span img{margin:0;text-align:right}.markdown-body span.float-left{display:block;float:left;margin-right:13px;overflow:hidden}.markdown-body span.float-left span{margin:13px 0 0}.markdown-body span.float-right{display:block;float:right;margin-left:13px;overflow:hidden}.markdown-body span.float-right>span{display:block;margin:13px auto 0;overflow:hidden;text-align:right}.markdown-body code,.markdown-body tt{padding:0;padding-top:.2em;padding-bottom:.2em;margin:0;font-size:85%;background-color:rgba(0,0,0,.04);border-radius:3px}.markdown-body code:after,.markdown-body code:before,.markdown-body tt:after,.markdown-body tt:before{letter-spacing:-.2em;content:"\00a0"}.markdown-body code br,.markdown-body tt br{display:none}.markdown-body del code{text-decoration:inherit}.markdown-body pre{word-wrap:normal}.markdown-body pre>code{padding:0;margin:0;font-size:100%;word-break:normal;white-space:pre;background:transparent;border:0}.markdown-body .highlight{margin-bottom:16px}.markdown-body .highlight pre{margin-bottom:0;word-break:normal}.markdown-body .highlight pre,.markdown-body pre{padding:16px;overflow:auto;font-size:85%;line-height:1.45;background-color:#f7f7f7;border-radius:3px}.markdown-body pre code,.markdown-body pre tt{display:inline;max-width:auto;padding:0;margin:0;overflow:visible;line-height:inherit;word-wrap:normal;background-color:transparent;border:0}.markdown-body pre code:after,.markdown-body pre code:before,.markdown-body pre tt:after,.markdown-body pre tt:before{content:normal}.markdown-body .csv-data td,.markdown-body .csv-data th{padding:5px;overflow:hidden;font-size:12px;line-height:1;text-align:left;white-space:nowrap}.markdown-body .csv-data .blob-line-num{padding:10px 8px 9px;text-align:right;background:#fff;border:0}.markdown-body .csv-data tr{border-top:0}.markdown-body .csv-data th{font-weight:700;background:#f8f8f8;border-top:0}.markdown-body kbd{display:inline-block;padding:3px 5px;font-size:11px;line-height:10px;color:#555;vertical-align:middle;background-color:#fcfcfc;border:1px solid #ccc;border-bottom-color:#bbb;border-radius:3px;box-shadow:inset 0 -1px 0 #bbb}.news .alert .markdown-body blockquote{padding:0 0 0 40px;border:0 none}.activity-tab .news .alert .commits,.activity-tab .news .markdown-body blockquote{padding-left:0}.task-list-item{list-style-type:none}.task-list-item label{font-weight:400}.task-list-item.enabled label{cursor:pointer}.task-list-item+.task-list-item{margin-top:3px}.task-list-item-checkbox{float:left;margin:.31em 0 .2em -1.3em!important;vertical-align:middle;cursor:default!important}.markdown-body{font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Helvetica,Arial,sans-serif;padding-top:40px;padding-bottom:40px;max-width:758px;overflow:visible!important}.markdown-body .emoji{vertical-align:top}.markdown-body pre{border:inherit!important}.markdown-body code{color:inherit!important}.markdown-body pre code .wrapper{display:-moz-inline-flex;display:-ms-inline-flex;display:-o-inline-flex;display:inline-flex}.markdown-body pre code .gutter{float:left;overflow:hidden;-webkit-user-select:none;user-select:none}.markdown-body pre code .gutter.linenumber{text-align:right;position:relative;display:inline-block;cursor:default;z-index:4;padding:0 8px 0 0;min-width:20px;box-sizing:content-box;color:#afafaf!important;border-right:3px solid #6ce26c!important}.markdown-body pre code .gutter.linenumber>span:before{content:attr(data-linenumber)}.markdown-body pre code .code{float:left;margin:0 0 0 16px}.markdown-body .gist .line-numbers{border-left:none;border-top:none;border-bottom:none}.markdown-body .gist .line-data{border:none}.markdown-body .gist table{border-spacing:0;border-collapse:inherit!important}.markdown-body code[data-gist-id]{background:none;padding:0}.markdown-body code[data-gist-id]:after,.markdown-body code[data-gist-id]:before{content:""}.markdown-body code[data-gist-id] .blob-num{border:unset}.markdown-body code[data-gist-id] table{overflow:unset;margin-bottom:unset}.markdown-body code[data-gist-id] table tr{background:unset}.markdown-body[dir=rtl] pre{direction:ltr}.markdown-body[dir=rtl] code{direction:ltr;unicode-bidi:embed}.markdown-body .alert>p{margin-bottom:0}.markdown-body pre.abc,.markdown-body pre.flow-chart,.markdown-body pre.graphviz,.markdown-body pre.mermaid,.markdown-body pre.sequence-diagram{text-align:center;background-color:inherit;border-radius:0;white-space:inherit}.markdown-body pre.abc>code,.markdown-body pre.flow-chart>code,.markdown-body pre.graphviz>code,.markdown-body pre.mermaid>code,.markdown-body pre.sequence-diagram>code{text-align:left}.markdown-body pre.abc>svg,.markdown-body pre.flow-chart>svg,.markdown-body pre.graphviz>svg,.markdown-body pre.mermaid>svg,.markdown-body pre.sequence-diagram>svg{max-width:100%;height:100%}.markdown-body pre>code.wrap{white-space:pre-wrap;white-space:-moz-pre-wrap;white-space:-pre-wrap;white-space:-o-pre-wrap;word-wrap:break-word}.markdown-body .alert>p,.markdown-body .alert>ul{margin-bottom:0}.markdown-body summary{display:list-item}.markdown-body summary:focus{outline:none}.markdown-body details summary{cursor:pointer}.markdown-body details:not([open])>:not(summary){display:none}.markdown-body figure{margin:1em 40px}.markdown-body .mark,.markdown-body mark{background-color:#fff1a7}.vimeo,.youtube{cursor:pointer;display:table;text-align:center;background-position:50%;background-repeat:no-repeat;background-size:contain;background-color:#000;overflow:hidden}.vimeo,.youtube{position:relative;width:100%}.youtube{padding-bottom:56.25%}.vimeo img{width:100%;object-fit:contain;z-index:0}.youtube img{object-fit:cover;z-index:0}.vimeo iframe,.youtube iframe,.youtube img{width:100%;height:100%;position:absolute;top:0;left:0}.vimeo iframe,.youtube iframe{vertical-align:middle;z-index:1}.vimeo .icon,.youtube .icon{position:absolute;height:auto;width:auto;top:50%;left:50%;transform:translate(-50%,-50%);color:#fff;opacity:.3;transition:opacity .2s;z-index:0}.vimeo:hover .icon,.youtube:hover .icon{opacity:.6;transition:opacity .2s}.slideshare .inner,.speakerdeck .inner{position:relative;width:100%}.slideshare .inner iframe,.speakerdeck .inner iframe{position:absolute;top:0;bottom:0;left:0;right:0;width:100%;height:100%}.MJX_Assistive_MathML{display:none}.ui-infobar{position:relative;z-index:2;max-width:758px;margin-top:25px;margin-bottom:-25px;color:#777}.ui-toc{position:fixed;bottom:20px;z-index:10000}.ui-toc-label{opacity:.3;background-color:#ccc;border:none;transition:opacity .2s}.ui-toc .open .ui-toc-label{opacity:1;color:#fff;transition:opacity .2s}.ui-toc-label:focus{opacity:.3;background-color:#ccc;color:#000}.ui-toc-label:hover{opacity:1;background-color:#ccc;transition:opacity .2s}.ui-toc-dropdown{margin-top:23px;margin-bottom:20px;padding-left:10px;padding-right:10px;max-width:45vw;width:25vw;max-height:70vh;overflow:auto;text-align:inherit}.ui-toc-dropdown>.toc{max-height:calc(70vh - 100px);overflow:auto}.ui-toc-dropdown[dir=rtl] .nav{padding-right:0;letter-spacing:.0029em}.ui-toc-dropdown a{overflow:hidden;text-overflow:ellipsis;white-space:pre}.ui-toc-dropdown .nav>li>a{display:block;padding:4px 20px;font-size:13px;font-weight:500;color:#767676}.ui-toc-dropdown .nav>li:first-child:last-child > ul,.ui-toc-dropdown .toc.expand ul{display:block}.ui-toc-dropdown .nav>li>a:focus,.ui-toc-dropdown .nav>li>a:hover{padding-left:19px;color:#000;text-decoration:none;background-color:transparent;border-left:1px solid #000}.ui-toc-dropdown[dir=rtl] .nav>li>a:focus,.ui-toc-dropdown[dir=rtl] .nav>li>a:hover{padding-right:19px;border-left:none;border-right:1px solid #000}.ui-toc-dropdown .nav>.active:focus>a,.ui-toc-dropdown .nav>.active:hover>a,.ui-toc-dropdown .nav>.active>a{padding-left:18px;font-weight:700;color:#000;background-color:transparent;border-left:2px solid #000}.ui-toc-dropdown[dir=rtl] .nav>.active:focus>a,.ui-toc-dropdown[dir=rtl] .nav>.active:hover>a,.ui-toc-dropdown[dir=rtl] .nav>.active>a{padding-right:18px;border-left:none;border-right:2px solid #000}.ui-toc-dropdown .nav .nav{display:none;padding-bottom:10px}.ui-toc-dropdown .nav>.active>ul{display:block}.ui-toc-dropdown .nav .nav>li>a{padding-top:1px;padding-bottom:1px;padding-left:30px;font-size:12px;font-weight:400}.ui-toc-dropdown[dir=rtl] .nav .nav>li>a{padding-right:30px}.ui-toc-dropdown .nav .nav>li>ul>li>a{padding-top:1px;padding-bottom:1px;padding-left:40px;font-size:12px;font-weight:400}.ui-toc-dropdown[dir=rtl] .nav .nav>li>ul>li>a{padding-right:40px}.ui-toc-dropdown .nav .nav>li>a:focus,.ui-toc-dropdown .nav .nav>li>a:hover{padding-left:29px}.ui-toc-dropdown[dir=rtl] .nav .nav>li>a:focus,.ui-toc-dropdown[dir=rtl] .nav .nav>li>a:hover{padding-right:29px}.ui-toc-dropdown .nav .nav>li>ul>li>a:focus,.ui-toc-dropdown .nav .nav>li>ul>li>a:hover{padding-left:39px}.ui-toc-dropdown[dir=rtl] .nav .nav>li>ul>li>a:focus,.ui-toc-dropdown[dir=rtl] .nav .nav>li>ul>li>a:hover{padding-right:39px}.ui-toc-dropdown .nav .nav>.active:focus>a,.ui-toc-dropdown .nav .nav>.active:hover>a,.ui-toc-dropdown .nav .nav>.active>a{padding-left:28px;font-weight:500}.ui-toc-dropdown[dir=rtl] .nav .nav>.active:focus>a,.ui-toc-dropdown[dir=rtl] .nav .nav>.active:hover>a,.ui-toc-dropdown[dir=rtl] .nav .nav>.active>a{padding-right:28px}.ui-toc-dropdown .nav .nav>.active>.nav>.active:focus>a,.ui-toc-dropdown .nav .nav>.active>.nav>.active:hover>a,.ui-toc-dropdown .nav .nav>.active>.nav>.active>a{padding-left:38px;font-weight:500}.ui-toc-dropdown[dir=rtl] .nav .nav>.active>.nav>.active:focus>a,.ui-toc-dropdown[dir=rtl] .nav .nav>.active>.nav>.active:hover>a,.ui-toc-dropdown[dir=rtl] .nav .nav>.active>.nav>.active>a{padding-right:38px}.markdown-body[lang^=ja]{font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Helvetica,Arial,Hiragino Kaku Gothic Pro,ヒラギノ角ゴ Pro W3,Osaka,Meiryo,メイリオ,MS Gothic,ＭＳ\ ゴシック,sans-serif}.ui-toc-dropdown[lang^=ja]{font-family:Source Sans Pro,Helvetica,Arial,Meiryo UI,MS PGothic,ＭＳ\ Ｐゴシック,sans-serif}.markdown-body[lang=zh-tw]{font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Helvetica,Arial,PingFang TC,Microsoft JhengHei,微軟正黑,sans-serif}.ui-toc-dropdown[lang=zh-tw]{font-family:Source Sans Pro,Helvetica,Arial,Microsoft JhengHei UI,微軟正黑UI,sans-serif}.markdown-body[lang=zh-cn]{font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Helvetica,Arial,PingFang SC,Microsoft YaHei,微软雅黑,sans-serif}.ui-toc-dropdown[lang=zh-cn]{font-family:Source Sans Pro,Helvetica,Arial,Microsoft YaHei UI,微软雅黑UI,sans-serif}.ui-affix-toc{position:fixed;top:0;max-width:15vw;max-height:70vh;overflow:auto}.back-to-top,.expand-toggle,.go-to-bottom{display:block;padding:4px 10px;margin-top:10px;margin-left:10px;font-size:12px;font-weight:500;color:#999}.back-to-top:focus,.back-to-top:hover,.expand-toggle:focus,.expand-toggle:hover,.go-to-bottom:focus,.go-to-bottom:hover{color:#563d7c;text-decoration:none}.back-to-top,.go-to-bottom{margin-top:0}.ui-user-icon{width:20px;height:20px;display:block;border-radius:3px;margin-top:2px;margin-bottom:2px;margin-right:5px;background-position:50%;background-repeat:no-repeat;background-size:contain}.ui-user-icon.small{width:18px;height:18px;display:inline-block;vertical-align:middle;margin:0 0 .2em}.ui-infobar>small>span{line-height:22px}.ui-infobar>small .dropdown{display:inline-block}.ui-infobar>small .dropdown a:focus,.ui-infobar>small .dropdown a:hover{text-decoration:none}.unselectable{-webkit-user-select:none;-o-user-select:none;user-select:none}@media print{blockquote,div,img,pre,table{page-break-inside:avoid!important}a[href]:after{font-size:12px!important}}.markdown-body.slides{position:relative;z-index:1;color:#222}.markdown-body.slides:before{content:"";display:block;position:absolute;top:0;left:0;right:0;bottom:0;z-index:-1;background-color:currentColor;box-shadow:0 0 0 50vw}.markdown-body.slides section[data-markdown]{position:relative;margin-bottom:1.5em;background-color:#fff;text-align:center}.markdown-body.slides section[data-markdown] code{text-align:left}.markdown-body.slides section[data-markdown]:before{content:"";display:block;padding-bottom:56.23%}.markdown-body.slides section[data-markdown]>div:first-child{position:absolute;top:50%;left:1em;right:1em;transform:translateY(-50%);max-height:100%;overflow:hidden}.markdown-body.slides section[data-markdown]>ul{display:inline-block}.markdown-body.slides>section>section+section:after{content:"";position:absolute;top:-1.5em;right:1em;height:1.5em;border:3px solid #777}body{font-smoothing:subpixel-antialiased!important;-webkit-font-smoothing:subpixel-antialiased!important;-moz-osx-font-smoothing:auto!important;text-shadow:0 0 1em transparent,1px 1px 1.2px rgba(0,0,0,.004);-webkit-overflow-scrolling:touch;font-family:Source Sans Pro,Helvetica,Arial,sans-serif;letter-spacing:.025em}.focus,:focus{outline:none!important}::-moz-focus-inner{border:0!important}body.modal-open{overflow-y:auto;padding-right:0!important}
    </style>
    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    	<script src="https://cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv.min.js" integrity="sha256-3Jy/GbSLrg0o9y5Z5n1uw0qxZECH7C6OQpVBgNFYa0g=" crossorigin="anonymous"></script>
    	<script src="https://cdnjs.cloudflare.com/ajax/libs/respond.js/1.4.2/respond.min.js" integrity="sha256-g6iAfvZp+nDQ2TdTR/VVKJf3bGro4ub5fvWSWVRi2NE=" crossorigin="anonymous"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/es5-shim/4.5.9/es5-shim.min.js" integrity="sha256-8E4Is26QH0bD52WoQpcB+R/tcWQtpzlCojrybUd7Mxo=" crossorigin="anonymous"></script>
    <![endif]-->
</head>

<body>
    <div id="doc" class="markdown-body container-fluid" style="position: relative;"><h1 id="B10502224-古智斌-OS-HW1"><a class="anchor hidden-xs" href="#B10502224-古智斌-OS-HW1" title="B10502224-古智斌-OS-HW1"><span class="octicon octicon-link"></span></a>B10502224 古智斌 OS　HW1</h1><h2 id="Part-1"><a class="anchor hidden-xs" href="#Part-1" title="Part-1"><span class="octicon octicon-link"></span></a>Part 1</h2><p><img src="https://i.imgur.com/uC5fQ3w.png" alt=""><br>
<img src="https://i.imgur.com/aXIfm3l.png" alt=""></p><p>When an x86 PC boots, it will execute a program called BIOS (Basic Input/Output System). BIOS will prepare the hardware and transfer control to the OS. It will transfer the control to code loaded from the boot sector, the first 512-byte sector of the boot disk. The boot sector contains the boot loader: instructions that load the kernel into memory. The BIOS loads the boot sector at memory address 0x7c00 and then jumps (sets the processor’s %ip, the instruction pointer) to that address. The loader’s job is to put the processor in a more modern operating mode, to load the xv6 kernel from disk into memory, and then to transfer control to the kernel. The BIOS doesn’t guarantee anything about the contents of %ds, %es, %ss, so first order of business after disabling interrupts is to set %ax to zero and then copy that zero into %ds, %es, and %ss.<br>
The boot loader’s first action in 32-bit mode is to initialize the data segment registers with SEG_KDATA. Logical address now map directly to physical addresses. The only step left before executing C code is to set up stack in an unused region of memory. The memory from 0xa0000 to 0x100000 is typically littered with device memory regions, and the xv6 kernel expects to be placed at 0x100000. The boot loader itself is at 0x7c00 through 0x7e00 (512 bytes). Essentially any other section of memory would be a fine location for the stack. The boot loader chooses 0x7c00 (known in this file as $start) as the top of the stack; the stack will grow down from there, toward 0x0000, away from the boot loader.</p><h2 id="Part-2"><a class="anchor hidden-xs" href="#Part-2" title="Part-2"><span class="octicon octicon-link"></span></a>Part 2</h2><h3 id="Chapter-0-Operating-Systems-Interfaces"><a class="anchor hidden-xs" href="#Chapter-0-Operating-Systems-Interfaces" title="Chapter-0-Operating-Systems-Interfaces"><span class="octicon octicon-link"></span></a>Chapter 0. Operating Systems Interfaces</h3><p>The job of an operating system is to share a computer among multiple programs and to provide a more useful set of services than the hardware alone supports. The operating system manages and abstracts the low-level hardware and shares the hardware among multiple programs. Operating systems also provide controlled ways for programs to interact, so that they can share data or work together.<br>
The kernel is a special program that provides services to running programs. Each running program, called a process, has memory containing instructions, data, and a stack. The instructions implement the program’s computation. The data are the variables on which the computation acts. The stack organizes the program’s procedure calls. When a process needs to invoke a kernel service, it invokes a procedure call called a system call. The system call enters the kernel; the kernel performs the service and returns. Thus a process alternates between executing in the user space and kernel space. The shell is an ordinary program that reads commands from the user and executes them; it’s the primary user interface to traditional Unix-like systems.<br>
An xv6 process consists of user-space memory (instructions, data, and stack) and per-process state private to the kernel. Xv6 time-shares between processes, when a process is not executing, xv6 saves its CPU registers, restoring them when it next runs the process. The kernel associates a process identifier (pid) with each process. A process is able to create a new process using the fork system call. Fork creates a new process called the child process with exactly the same memory contents as the calling process (parent process). Fork returns in both the parent and the child. In the parent, fork returns the child’s pid; while in the child it returns zero. The exit system call causes the calling process to stop executing and to release resources such as memory and open files. The wait system call returns the pid of an exited child of the current process; if none of the callers children has exited, wait waits for one to do so. The exec system call replaces the calling process’s memory with a new memory image loaded from a file stored in the file system. The file must have a particular format, which specifies which part of the file holds instructions, which part is data, at which instruction to start. The main structure of the shell is as follows: the main loop reads a line of input from the user with getcmd, then it calls fork, which creates a copy of the shell process; the parent calls wait, while the child runs the command. Fork allocates the memory required for the child’s copy of the parent’s memory, and exec allocates enough memory to hold the executable file, if the process needs more memory at run-time, it can call sbrk(n) to grow its data memory by n bytes; sbrk will return  the location of the new memory.<br>
A file descriptor is a small integer representing a kernel-managed object that a process may read from or write to. A process reads from file descriptor 0 (standard input), writes output to file descriptor 1 (standard output), and writes error messages to file descriptor 2 (standard error). The call read(fd, buf, n) reads at most n bytes from the file descriptor fd, copies them into buf, and returns the number of bytes read. The call write read(fd, buf, n) writes n bytes from buf to the file descriptor fd and returns the number of bytes written. The close system call releases a file descriptor, making it free for reuse by a future open, pipe, or dup system call. File descriptors and fork interact to make I/O redirection easy to implement. Fork copies the parent’s file descriptor table along with its memory; the system call exec will replace the calling process’s memory but preserves its file table. It’s a good idea to separate fork and exec in two different calls, the reason is because the shell can fork a child, use open, close, dup in the child to change the standard input and output file descriptors, and then exec. The dup system call duplicates an existing file descriptor, returning a new one that refers to the same underling I/O object. Both file descriptors share an offset, just as the file descriptors duplicated by fork do. Two file descriptors share an offset if they were derived from the same original file descriptor by a sequence of fork and dup calls. Otherwise file descriptors do not share offsets, even if they resulted from open calls for the same file.<br>
A pipe is a small kernel buffer exposed to processes as a pair of file descriptors, one for reading and one for writing. Writing data to one end of the pipe makes that data available for reading from the other end of the pipe. Pipes provide a way for processes to communicate. If no data is available, a read on a pipe waits for either data to be written or all file descriptors referring to the write end to be closed. The advantages of pipes over temporary files are: first, they clean themselves up; second, they can pass arbitrarily long streams of data; third, pipes allow parallel execution of pipeline stages; and fourth, if you’re implementing inter-process communication, pipes’ blocking reads and writes are more efficient than the non-blocking semantics of files.<br>
The xv6 file system provides data files, which are uninterpreted byte arrays, and directories, which contain named references to data files and other directories. The directories form a tree, starting at a special directory called the root. You can use mkdir to create a new directory, open with the 0_CREATE flag to create a new data file, and mknod to create a new device file. A file’s name is distinct from the file itself; the same underlying file, called an inode, can have multiple names, called links. The link system call creates another file system name referring to the same inode as an existing file.</p><h3 id="Chapter-1-Operating-Systems-Organization"><a class="anchor hidden-xs" href="#Chapter-1-Operating-Systems-Organization" title="Chapter-1-Operating-Systems-Organization"><span class="octicon octicon-link"></span></a>Chapter 1. Operating Systems Organization</h3><p>A key requirement for an operating system is to support several activities at once. An operating system must fulfil three requirements: multiplexing, isolation, and interaction. Strong isolation requires a hard boundary between applications and the operating system. Processors provide hardware support for strong isolation. The xv6 processor has two modes in which the processor can execute instructions: kernel mode and user mode. In kernel mode the processor is allowed to execute privileged instructions. An application can execute only user-mode instructions and is said to be running in user space, while the software in kernel mode can also execute privileged instructions and is said to be running in kernel space. The software running in kernel space (or in kernel mode) is called the kernel.  An application that wants to read or write a file on disk must transition to the kernel to do so, because the application itself cannot execute I/O instructions. Processors provide a special instruction that switches the processor from user mode to kernel mode and enters the kernel at an entry point specified by the kernel (the x86 processor provides the int instruction for this purpose).<br>
Many Unix operating systems uses monolithic kernel, in this organization, the entire operating system resides in the kernel so that implementations of all system calls run in kernel mode, so the entire operating system will run with full hardware privilege. A downside of the monolithic organization is that the interfaces between different parts of the operating system are often complex, making it easy for the OS developer to make a mistake. In a monolithic kernel, a mistake is fatal, because an error in kernel mode will often result in the kernel to fail, causing the computer to stop working, all applications will fail too and the computer must reboot to start again. One way to reduce the risk of mistakes is by minimizing the amount of operating system code that runs in kernel mode, and execute the bulk of the OS in user mode. This kernel organization is called microkernel. OS services running as processes are called servers. In a microkernel, the kernel interface consists of a few low-level functions. This organization allows the kernel to be relatively simple, as most of the operating system resides in user-level servers. Xv6 is implemented as a monolithic kernel, following most Unix OS. In xv6, the kernel interface corresponds to the operating system interface, and the kernel implements the complete operating system.<br>
The unit of isolation in xv6 (as in other Unix OS) is a process. The process abstraction prevents one process from wrecking or spying on another process’ memory, CPU, file descriptors. The mechanisms used by the kernel to implement processes include the user/kernel mode flag, address spaces, and time-slicing of threads. A process provides a program with what appears to be a private memory system, or address space, which other processes cannot read or write. A process also provides the program with what appears to be its own CPU to execute the program’s instructions. Xv6 uses page tables (which are implemented by hardware) to give each process its own address space. The x86 page table translates (or “maps”) a virtual address (the address that an x86 instruction manipulates) to a physical address (an address that the processor chip sends to main memory). An address space includes the process’s user memory starting at virtual address zero. In order to leave plenty of room for user memory, xv6’s address spaces map the kernel at high addresses, starting at 0x80100000. The xv6 kernel maintains many pieces of state for each process, which it gathers into a struct proc. A process’s most important pieces of kernel state are its page table, its kernel stack, and its run state. We’ll use the notation p-&gt;xxx to refer to elements of the proc structure. Each process has two stacks: a user stack and a kernel stack (p-&gt;kstack). When the process is executing user instructions, only its user stack is in use, and its kernel stack is empty. When the process enters the kernel (for a system call or interrupt), the kernel code executes on the process’s kernel stack; while a process is in the kernel, its user stack still contains saved data, but isn’t actively used. When a process makes a system call, the processor switches to the kernel stack, raises the hardware privilege level, and starts executing the kernel instructions that implement the system call. p-&gt;state indicates whether the process is allocated, ready to run, running, waiting for I/O, or exiting. p-&gt;pgdir holds the process’s page table, which serves as the record of the addresses of the physical pages allocated to store the process’s memory.<br>
The first step in providing strong isolation is setting up the kernel to run in its own address space. When a PC powers on, it initializes itself and then loads a boot loader from disk into memory and executes it. Xv6’s boot loader loads the xv6 kernel from disk and executes it starting at entry. The boot loader loads the xv6 kernel into memory at physical address 0x100000. The reason it doesn’t load the kernel at 0x80100000, where the kernel expects to find its instructions and data, is that there may not be any physical memory at such a high address on a small machine. The reason it places the kernel at 0x100000 rather than 0x0 is because the address range 0xa0000:0x100000 contains I/O devices. To allow the rest of the kernel to run, entry sets up a page table that maps virtual addresses starting at 0x80000000 (called KERNBASE) to physical addresses starting at 0x0. Now entry needs to transfer to the kernel’s C code, and run it in high memory. First it makes the stack pointer, %esp, point to memory to be used as a stack. All symbols have high addresses, including stack, so the stack will still be valid even when the low mappings are removed. Finally entry jumps to main, which is also a high address. The indirect jump is needed because the assembler would otherwise generate a PC-relative direct jump, which would execute the low-memory version of main. Main cannot return, since there’s no return PC on the stack. Now the kernel is running in high addresses in the function main.<br>
After main initializes several devices and subsystems, it creates the first process by calling userinit. Userinit’s first action is to call allocproc. The job of allocproc is to allocate a slot (a struct proc) in the process table and to initialize the parts of the process’s state required for its kernel thread to execute. Allocproc is called for each new process, while userinit is called only for the very first process. Allocproc scans the proc table for a slot with state UNUSED. When it finds an unused slot, allocproc sets the state to EMBRYO to mark it as used and gives the process a unique pid. Next, it tries to allocate a kernel stack for the process’s kernel thread. If the memory allocation fails, allocproc changes the state back to UNUSED and returns zero to signal failure. The way that control transfers from user software to the kernel is via an interrupt mechanism, which is used by system calls, interrupts, and exceptions. Whenever control transfers into the kernel while a process is running, the hardware and xv6 trap entry code save user registers on the process’s kernel stack. The stack pointer %esp is set to the process’s largest valid virtual address, p-&gt;sz. The instruction pointer is set to the entry point for the initcode, address 0. Once the process is initialized, userinit marks it available for scheduling by setting p-&gt;state to RUNNABLE.<br>
After the first process is prepared, we can start running it. After main calls userinit, mpmain calls scheduler to start running processes. scheduler looks for a process with p-&gt;state set to RUNNABLE, and there’s only one: initproc. scheduler now sets p-&gt;state to RUNNING and calls swtch to perform context switch to the target process’s kernel thread. swtch first saves the current registers. The current context is not a process but rather a special per-cpu scheduler context, so scheduler tells swtch to save the current hardware registers in per-cpu storage (cpu-&gt;scheduler) rather than in any process’s kernel thread context. swtch then loads the saved registers of the target kernel thread (p-&gt;context into the x86 hardware registers, including the stack pointer and instruction pointer. The final ret instruction pops the target process’s %eip from the stack, finishing the context switch. Now the processor is running on the kernel stack of process p.<br>
The first action of initcode.S is to invoke the exec system call. Exec replaces the memory and registers of the current process with a new program, but it leaves the file descriptors, process id, and parent process unchanged. Initcode.S begins by pushing three values on the stack --$argv, $init, and $0—and then sets %eax to SYS_exec and executes int T_SYSCALL: it is asking the kernel to run the exec system call. Exec at a high level replaces initcode with the /init binary, loaded out of the file system. Now init-code is done, and the process will run /init instead. Init creates a new console device file if needed and then opens it as file descriptors 0, 1, and 2. Then it loops, starting a console shell, handles orphaned zombies until the shell exits, and repeats. The system is up.</p><h2 id="Part-3"><a class="anchor hidden-xs" href="#Part-3" title="Part-3"><span class="octicon octicon-link"></span></a>Part 3</h2><h3 id="Chapter-6-File-Systems"><a class="anchor hidden-xs" href="#Chapter-6-File-Systems" title="Chapter-6-File-Systems"><span class="octicon octicon-link"></span></a>Chapter 6. File Systems</h3><p><img src="https://i.imgur.com/ghSVNDZ.jpg" alt=""><br>
The purpose of a file system is to organize and store data. File systems typically support sharing of data among users and applications, as well as persistence so that data is still available after a reboot. The xv6 file system implementation is organized in seven layers, shown in Figure 6-1. The disk layer reads and writes blocks on an IDE hard drive. The buffer cache layer caches disk blocks and synchronizes access to them, making sure that only one kernel process at a time can modify the data stored in any particular block. The logging layer allows higher layers to wrap updates to several blocks in a transaction, and ensures that the blocks are updated atomically in the face of crashes (i.e., all of them are updated or none). The inode layer provides individual files, each represented as an inode with a unique i-number and some blocks holding the file’s data. The directory layer implements each directory as a special kind of inode whose content is a sequence of directory entries, each of which contains a file’s name and i-number. The pathname layer provides hierarchical path names like /usr/rtm/xv6/fs.c, and resolves them with recursive lookup. The file descriptor layer abstracts many Unix resources (e.g., pipes, devices, files, etc.) using the file system interface, simplifying the lives of application programmers.<br>
<img src="https://i.imgur.com/vyynrFK.jpg" alt=""><br>
The file system must have a plan for where it stores inodes and content blocks on the disk. To do so, xv6 divides the disk into several sections, as shown in Figure 6-2. The file system does not use block 0 (it holds the boot sector). Block 1 is called the superblock; it contains metadata about the file system (the file system size in blocks, the number of data blocks, the number of inodes, and the number of blocks in the log). Blocks starting at 2 hold the log. After the log are the inodes, with multiple inodes per block. After those come bitmap blocks tracking which data blocks are in use. The remaining blocks are data blocks; each is either marked free in the bitmap block, or holds content for a file or directory. The superblock is filled in by a separate program, called mfks, which builds an initial file system.<br>
<img src="https://i.imgur.com/Wu2kSNi.jpg" alt=""><br>
The on-disk inode structure, struct dinode, contains a size and an array of block numbers. The inode data is found in the blocks listed in the dinode’s addrs array.</p><h4 id="File-System-Layers"><a class="anchor hidden-xs" href="#File-System-Layers" title="File-System-Layers"><span class="octicon octicon-link"></span></a>File System Layers</h4><p>Each layer’s principal functions are described briefly below:</p><h5 id="Buffer-cache-layer"><a class="anchor hidden-xs" href="#Buffer-cache-layer" title="Buffer-cache-layer"><span class="octicon octicon-link"></span></a>Buffer cache layer</h5><p>Buffer cache: it has two jobs, first it synchronize access to disk blocks to ensure that only one copy of a block is in memory and that only one kernel thread at a time uses that copy; second is to cache popular blocks so that they don’t need to be re-read from the slow disk. The buffer cache is a linked list of buf structures holding cached copies of disk block contents. Caching disk blocks in memory reduces the number of disk reads and also provides a synchronization point for disk blocks used by multiple processes. To get a buffer for a particular disk block, call bread.  After changing buffer data, call bwrite to write it to disk. When done with the buffer, call brelse. Do not use the buffer after calling brelse.  Only one process at a time can use a buffer, so do not keep them longer than necessary.</p><pre><code>struct buf { 
int flags; 
uint dev; 
uint blockno; 
struct sleeplock lock;  
uint refcnt; 
struct buf *prev; // LRU cache list 
struct buf *next; 
struct buf *qnext; // disk queue 
uchar data[BSIZE]; 
}; 
#define B_VALID 0x2 // buffer has been read from disk and contains a copy of the block.
#define B_DIRTY 0x4 // buffer needs to be written to disk because content has been modified.


// sleep-lock protects reads and writes of the block’s buffered content, because only one process at a time can use a buffer.
// Long−term locks for processes 
struct sleeplock { 
uint locked; // Is the lock held? 
struct spinlock lk; // spinlock protecting this sleep lock 

// For debugging: 
char *name; // Name of lock. 
int pid; // Process holding lock 
 };

//Creating a new buffer.
struct {
struct spinlock lock;
struct buf buf[NBUF];
// Linked list of all buffers, through prev/next.
// head.next is most recently used.
struct buf head;
} bcache;
</code></pre><h5 id="Logging-Layer"><a class="anchor hidden-xs" href="#Logging-Layer" title="Logging-Layer"><span class="octicon octicon-link"></span></a>Logging Layer</h5><p>Logging layer solves the problem of crashes during file system operations with a simple form of logging. An xv6 system call does not directly write the on-disk file system data structures. Instead, it places a description of all the disk writes it wishes to make in a log on the disk. Once the system call has logged all of its writes, it writes a special commit record to the disk indicating that the log contains a complete operation. At that point the system call copies the writes to the on-disk file system data structures. After those writes have completed, the system call erases the log on disk. The log makes operations atomic with respect to crashes: after recovery, either all of the operation’s writes appear on the disk, or none of them appear. Log is able to commit several transactions together through group commit. Group commit reduces the number of disk operations and hands the disk system more concurrent writes at the same time.</p><pre><code>// Contents of the header block, used for both the on−disk header block 
// and to keep track in memory of logged block# before commit. 
struct logheader { 
int n; 
int block[LOGSIZE]; 
}; 
struct log { 
struct spinlock lock; 
 int start; 
int size; 
int outstanding; // how many FS sys calls are executing. 
int committing; // in commit(), please wait. 
int dev; 
struct logheader lh; 
 };

// log_write() acts as a proxy for bwrite. It records the block’s sector number in memory, reserving it a slot in the log on disk, and marks the buffer B_DIRTY to prevent the block cache from evicting it. It notices when a block is written multiple times during a single  transaction, and allocates that block the same slot in the log. This optimization is called absorption.
//log_write() replaces bwrite(); a typical use is:
// bp = bread(...)
// modify bp−&gt;data[]
// log_write(bp)
// brelse(bp)
void
log_write(struct buf *b)
{
int i;
if (log.lh.n &gt;= LOGSIZE || log.lh.n &gt;= log.size − 1)
panic("too big a transaction");
if (log.outstanding &lt; 1)
panic("log_write outside of trans");
acquire(&amp;log.lock);
for (i = 0; i &lt; log.lh.n; i++) {
if (log.lh.block[i] == b−&gt;blockno) // log absorbtion
break;
}
log.lh.block[i] = b−&gt;blockno;
if (i == log.lh.n)
log.lh.n++;
b−&gt;flags |= B_DIRTY; // prevent eviction
release(&amp;log.lock);
}

//end_op decrements the count of outstanding system calls. If the count is zero, it commits the transaction by calling commit().
end_op(void)
{
int do_commit = 0;

acquire(&amp;log.lock);
log.outstanding −= 1;
if(log.committing)
panic("log.committing");
if(log.outstanding == 0){
do_commit = 1;
log.committing = 1;
} else {
// begin_op() may be waiting for log space,
// and decrementing log.outstanding has decreased
// the amount of reserved space.
wakeup(&amp;log);
}
release(&amp;log.lock);
if(do_commit){
// call commit w/o holding locks, since not allowed
// to sleep with locks.
commit();
acquire(&amp;log.lock);
log.committing = 0;
wakeup(&amp;log);
release(&amp;log.lock);
}
}

</code></pre><h5 id="Inode-Layer"><a class="anchor hidden-xs" href="#Inode-Layer" title="Inode-Layer"><span class="octicon octicon-link"></span></a>Inode Layer</h5><p>Inode might refer to on-disk data structure containing a file’s size and list of data block numbers. It might also refer to an in-memory inode, which contains a copy of the on-disk inode as well as extra information needed within the kernel. The on-disk inode is defined by a struct dinode and are packed into contiguous area of disk called inode blocks, it has a i-number n which is how they are identified in the implementation. An inode describes a single unnamed file. The inode disk structure holds metadata: the file’s type, its size, the number of links referring to it, and the list of blocks holding the file’s content.</p><pre><code>// On−disk inode structure
struct dinode {
short type; // File type
short major; // Major device number (T_DEV only)
short minor; // Minor device number (T_DEV only)
short nlink; // Number of links to inode in file system
uint size; // Size of file (bytes)
uint addrs[NDIRECT+1]; // Data block addresses
};
// in−memory copy of an inode
struct inode {
uint dev; // Device number
uint inum; // Inode number
int ref; // Reference count
struct sleeplock lock; // protects everything below here
int valid; // inode has been read from disk?
short type; // copy of disk inode
short major;
short minor;
short nlink;
uint size;
uint addrs[NDIRECT+1];
};

struct {
struct spinlock lock;
struct inode inode[NINODE];
} icache;
void
iinit(int dev)
{
int i = 0;
initlock(&amp;icache.lock, "icache");
for(i = 0; i &lt; NINODE; i++) {
initsleeplock(&amp;icache.inode[i].lock, "inode");
}
readsb(dev, &amp;sb);
cprintf("sb: size %d nblocks %d ninodes %d nlog %d logstart %d\
inodestart %d bmap start %d\n", sb.size, sb.nblocks,
sb.ninodes, sb.nlog, sb.logstart, sb.inodestart,
sb.bmapstart);
}
static struct inode* iget(uint dev, uint inum);


// Allocate an inode on device dev.
// Mark it as allocated by giving it type type.
// Returns an unlocked but allocated and referenced inode.
struct inode*
ialloc(uint dev, short type)
{
int inum;
struct buf *bp;
struct dinode *dip;
for(inum = 1; inum &lt; sb.ninodes; inum++){
bp = bread(dev, IBLOCK(inum, sb));
dip = (struct dinode*)bp−&gt;data + inum%IPB;
if(dip−&gt;type == 0){ // a free inode
memset(dip, 0, sizeof(*dip));
dip−&gt;type = type;
log_write(bp); // mark it allocated on the disk
brelse(bp);
return iget(dev, inum);
}
brelse(bp);
}
panic("ialloc: no inodes");
}


//iget() provides non-exclusive access to an inode, so that there can be many pointers to the same inode, it holds long-term references to inodes and prevents races while avoiding deadlock. To ensure an inode holds a copy of the on-disk inode, code must call ilock. This will lock the inode so that no other process can ilock it and reads the inode from disk, if it has not already been read. Iunlock releases the lock on the inode.
// Find the inode with number inum on device dev
// and return the in−memory copy. Does not lock
// the inode and does not read it from disk.
static struct inode*
iget(uint dev, uint inum)
{
struct inode *ip, *empty;
acquire(&amp;icache.lock);
// Is the inode already cached?
empty = 0;
for(ip = &amp;icache.inode[0]; ip &lt; &amp;icache.inode[NINODE]; ip++){
if(ip−&gt;ref &gt; 0 &amp;&amp; ip−&gt;dev == dev &amp;&amp; ip−&gt;inum == inum){
ip−&gt;ref++;
release(&amp;icache.lock);
return ip;
}
if(empty == 0 &amp;&amp; ip−&gt;ref == 0) // Remember empty slot.
empty = ip;
}



// Lock the given inode.
// Reads the inode from disk if necessary.
void
ilock(struct inode *ip)
{
struct buf *bp;
struct dinode *dip;
if(ip == 0 || ip−&gt;ref &lt; 1)
panic("ilock");
acquiresleep(&amp;ip−&gt;lock);
if(ip−&gt;valid == 0){
bp = bread(ip−&gt;dev, IBLOCK(ip−&gt;inum, sb));
dip = (struct dinode*)bp−&gt;data + ip−&gt;inum%IPB;
ip−&gt;type = dip−&gt;type;
ip−&gt;major = dip−&gt;major;
ip−&gt;minor = dip−&gt;minor;
ip−&gt;nlink = dip−&gt;nlink;
ip−&gt;size = dip−&gt;size;
memmove(ip−&gt;addrs, dip−&gt;addrs, sizeof(ip−&gt;addrs));
brelse(bp);
ip−&gt;valid = 1;
if(ip−&gt;type == 0)
panic("ilock: no type");
}
}
// Unlock the given inode.
void
iunlock(struct inode *ip)
{
if(ip == 0 || !holdingsleep(&amp;ip−&gt;lock) || ip−&gt;ref &lt; 1)
panic("iunlock");
releasesleep(&amp;ip−&gt;lock);
}

//iput releases a C pointer to an inode by decrementing the reference count. If this is the last reference, the inode’s slot in the inode cache is now free and can be re-used for a different inode. Iput calls intrunc to truncate the file to zero bytes, freeing the data blocks; sets the inode type to 0 (unallocated); and writes the inode to disk. Iput doesn’t truncate a file immediately when the link count for the file drops to zero, because some process might still hold a reference to the inode in memory: a process might still be reading and writing to the file, because it successfully opened it. But, if a crash happens before the last process closes the file descriptor for the file, then the file will be marked allocated on disk but no directory entry points to it.
// Drop a reference to an in−memory inode.
// If that was the last reference, the inode cache entry can
// be recycled.
// If that was the last reference and the inode has no links
// to it, free the inode (and its content) on disk.
// All calls to iput() must be inside a transaction in
// case it has to free the inode.
void
iput(struct inode *ip)
{
acquiresleep(&amp;ip−&gt;lock);
if(ip−&gt;valid &amp;&amp; ip−&gt;nlink == 0){
acquire(&amp;icache.lock);
int r = ip−&gt;ref;
release(&amp;icache.lock);
if(r == 1){
// inode has no links and no other references: truncate and free.
itrunc(ip);
ip−&gt;type = 0;
iupdate(ip);
ip−&gt;valid = 0;
}
}
releasesleep(&amp;ip−&gt;lock);
acquire(&amp;icache.lock);
ip−&gt;ref−−;
release(&amp;icache.lock);
} 
// Truncate inode (discard contents).
// Only called when the inode has no links
// to it (no directory entries referring to it)
// and has no in−memory reference to it (is
// not an open file or current directory).
static void
itrunc(struct inode *ip)
{
int i, j;
struct buf *bp;
uint *a;
for(i = 0; i &lt; NDIRECT; i++){
if(ip−&gt;addrs[i]){
bfree(ip−&gt;dev, ip−&gt;addrs[i]);
ip−&gt;addrs[i] = 0;
}
}
if(ip−&gt;addrs[NDIRECT]){
bp = bread(ip−&gt;dev, ip−&gt;addrs[NDIRECT]);
a = (uint*)bp−&gt;data;
for(j = 0; j &lt; NINDIRECT; j++){
if(a[j])
bfree(ip−&gt;dev, a[j]);
}
brelse(bp);
bfree(ip−&gt;dev, ip−&gt;addrs[NDIRECT]);
ip−&gt;addrs[NDIRECT] = 0;
}
ip−&gt;size = 0;
iupdate(ip);
}

</code></pre><h5 id="Directory-Layer"><a class="anchor hidden-xs" href="#Directory-Layer" title="Directory-Layer"><span class="octicon octicon-link"></span></a>Directory Layer</h5><p>A directory is implemented internally much like a file. Its inode has type T_DIR and its data is a sequence of directory entries. Each entry is a struct dirent which contains a name and an inode number. Dirlookup searches a directory for an entry with the given name. If dirlookup finds an entry with the right name, it updates*poff, releases the block, and returns an unlocked inode obtained via iget. Dirlookup is the reason that iget returns unlocked inodes. Dirlink writes a new directory entry with the given name and inode number into the directory dp, if the name already exists, dirlink returns an error.</p><pre><code>// Look for a directory entry in a directory.
// If found, set *poff to byte offset of entry.
struct inode*
dirlookup(struct inode *dp, char *name, uint *poff)
{
uint off, inum;
struct dirent de;
if(dp−&gt;type != T_DIR)
panic("dirlookup not DIR");
for(off = 0; off &lt; dp−&gt;size; off += sizeof(de)){
if(readi(dp, (char*)&amp;de, off, sizeof(de)) != sizeof(de))
panic("dirlookup read");
if(de.inum == 0)
continue;
if(namecmp(name, de.name) == 0){
// entry matches path element
if(poff)
*poff = off;
inum = de.inum;
return iget(dp−&gt;dev, inum);
}
}
return 0;
}
// Write a new directory entry (name, inum) into the directory dp.
int
dirlink(struct inode *dp, char *name, uint inum)
{
int off;
struct dirent de;
struct inode *ip;
// Check that name is not present.
if((ip = dirlookup(dp, name, 0)) != 0){
iput(ip);
return −1;
}

// Look for an empty dirent.
for(off = 0; off &lt; dp−&gt;size; off += sizeof(de)){
if(readi(dp, (char*)&amp;de, off, sizeof(de)) != sizeof(de))
panic("dirlink read");
if(de.inum == 0)
break;
}

strncpy(de.name, name, DIRSIZ);
de.inum = inum;
if(writei(dp, (char*)&amp;de, off, sizeof(de)) != sizeof(de))
panic("dirlink");
return 0;
}

</code></pre><h5 id="Path-Names-Layer"><a class="anchor hidden-xs" href="#Path-Names-Layer" title="Path-Names-Layer"><span class="octicon octicon-link"></span></a>Path Names Layer</h5><p>Namei evaluates path and returns the corresponding inode. The function nameiparent is a variant: it stops before the last element, returning the inode of the parent directory and copying the final element into name. Namex starts by deciding where the path evaluation begins. Then it uses skipelem to consider each element of the path in turn. Each iteration of the loop must look up name in the current inode ip.</p><pre><code>// Look up and return the inode for a path name.
// If parent != 0, return the inode for the parent and copy the final
// path element into name, which must have room for DIRSIZ bytes.
// Must be called inside a transaction since it calls iput().
static struct inode*
namex(char *path, int nameiparent, char *name)
{
struct inode *ip, *next;
if(*path == ’/’)
ip = iget(ROOTDEV, ROOTINO);
else
ip = idup(myproc()−&gt;cwd);
while((path = skipelem(path, name)) != 0){
ilock(ip);
if(ip−&gt;type != T_DIR){
iunlockput(ip);
return 0;
}
if(nameiparent &amp;&amp; *path == ’\0’){
// Stop one level early.
iunlock(ip);
return ip;
}
if((next = dirlookup(ip, name, 0)) == 0){
iunlockput(ip);
return 0;
}
iunlockput(ip);
ip = next;
}
if(nameiparent){
iput(ip);
return 0;
}
return ip;
}
struct inode*
namei(char *path)
{
char name[DIRSIZ];
return namex(path, 0, name);
}
struct inode*
nameiparent(char *path, char *name)
{
return namex(path, 1, name);
}

</code></pre><h5 id="File-Descriptor-Layer"><a class="anchor hidden-xs" href="#File-Descriptor-Layer" title="File-Descriptor-Layer"><span class="octicon octicon-link"></span></a>File Descriptor Layer</h5><p>Most resources in Unix are represented as files. The file descriptor layer is the layer that achieves this uniformity. Each open file is represented by a struct file. All the open files in the system are kept in a global file table, the ftable. The file table has a function to allocate a file, create a duplicate reference and release a reference, and read and write data. File alloc scans the file table for an unreferenced file (f-&gt;ref==0) and returns a new reference; filedup increments the reference count; and fileclose decrements it. When a file’s reference count reaches zero, fileclose release the underlying pipe or inode, according to the type. The functions filestat, fileread, and filewrite implement the stat, read, and write operations on files. Filestat is only allowed on inodes and calls stati. Fileread and filewrite check that the operation is allowed by the open mode and then pass the call through to either the pipe or inode implementation.</p><pre><code>// Allocate a file structure.
struct file*
filealloc(void)
{
struct file *f;
acquire(&amp;ftable.lock);
for(f = ftable.file; f &lt; ftable.file + NFILE; f++){
if(f−&gt;ref == 0){
f−&gt;ref = 1;
release(&amp;ftable.lock);
return f;
}
}
release(&amp;ftable.lock);
return 0;
}
// Increment ref count for file f.
struct file*
filedup(struct file *f)
{
acquire(&amp;ftable.lock);
if(f−&gt;ref &lt; 1)
panic("filedup");
f−&gt;ref++;
release(&amp;ftable.lock);
return f;
}
// Close file f. (Decrement ref count, close when reaches 0.)
void
fileclose(struct file *f)
{
struct file ff;
acquire(&amp;ftable.lock);
if(f−&gt;ref &lt; 1)
panic("fileclose");
if(−−f−&gt;ref &gt; 0){
release(&amp;ftable.lock);
return;
}
ff = *f;
f−&gt;ref = 0;
f−&gt;type = FD_NONE;
release(&amp;ftable.lock);
if(ff.type == FD_PIPE)
pipeclose(ff.pipe, ff.writable);
else if(ff.type == FD_INODE){
begin_op();
iput(ff.ip);
end_op();
}
}
// Get metadata about file f.
int
filestat(struct file *f, struct stat *st)
{
if(f−&gt;type == FD_INODE){
ilock(f−&gt;ip);
stati(f−&gt;ip, st);
iunlock(f−&gt;ip);
return 0;
}
return −1;
}
// Read from file f.
int
fileread(struct file *f, char *addr, int n)
{
int r;

if(f−&gt;readable == 0)
return −1;
if(f−&gt;type == FD_PIPE)
return piperead(f−&gt;pipe, addr, n);
if(f−&gt;type == FD_INODE){
ilock(f−&gt;ip);
if((r = readi(f−&gt;ip, addr, f−&gt;off, n)) &gt; 0)
f−&gt;off += r;
iunlock(f−&gt;ip);
return r;
}
panic("fileread");
}
// Write to file f.
int
filewrite(struct file *f, char *addr, int n)
{
int r;

if(f−&gt;writable == 0)
return −1;
if(f−&gt;type == FD_PIPE)
return pipewrite(f−&gt;pipe, addr, n);
if(f−&gt;type == FD_INODE){
// write a few blocks at a time to avoid exceeding
// the maximum log transaction size, including
// i−node, indirect block, allocation blocks,
// and 2 blocks of slop for non−aligned writes.
// this really belongs lower down, since writei()
// might be writing a device like the console.
int max = ((LOGSIZE−1−1−2) / 2) * 512;
int i = 0;
while(i &lt; n){
int n1 = n − i;
if(n1 &gt; max)
n1 = max;
begin_op();
ilock(f−&gt;ip);
if ((r = writei(f−&gt;ip, addr + i, f−&gt;off, n1)) &gt; 0)
f−&gt;off += r;
iunlock(f−&gt;ip);
end_op();
if(r &lt; 0)
break;
if(r != n1)
panic("short filewrite");
i += r;
}
return i == n ? n : −1;
}
panic("filewrite");
}
</code></pre></div>
    <div class="ui-toc dropup unselectable hidden-print" style="display:none;">
        <div class="pull-right dropdown">
            <a id="tocLabel" class="ui-toc-label btn btn-default" data-toggle="dropdown" href="#" role="button" aria-haspopup="true" aria-expanded="false" title="Table of content">
                <i class="fa fa-bars"></i>
            </a>
            <ul id="ui-toc" class="ui-toc-dropdown dropdown-menu" aria-labelledby="tocLabel">
                <div class="toc"><ul class="nav"><li class=""><a href="#B10502224-古智斌-OS-HW1" title="B10502224 古智斌 OS　HW1">B10502224 古智斌 OS　HW1</a><ul class="nav"><li><a href="#Part-1" title="Part 1">Part 1</a></li><li><a href="#Part-2" title="Part 2">Part 2</a><ul class="nav"><li><a href="#Chapter-0-Operating-Systems-Interfaces" title="Chapter 0. Operating Systems Interfaces">Chapter 0. Operating Systems Interfaces</a></li><li><a href="#Chapter-1-Operating-Systems-Organization" title="Chapter 1. Operating Systems Organization">Chapter 1. Operating Systems Organization</a></li></ul></li><li><a href="#Part-3" title="Part 3">Part 3</a><ul class="nav"><li><a href="#Chapter-6-File-Systems" title="Chapter 6. File Systems">Chapter 6. File Systems</a></li></ul></li></ul></li></ul></div><div class="toc-menu"><a class="expand-toggle" href="#">Expand all</a><a class="back-to-top" href="#">Back to top</a><a class="go-to-bottom" href="#">Go to bottom</a></div>
            </ul>
        </div>
    </div>
    <div id="ui-toc-affix" class="ui-affix-toc ui-toc-dropdown unselectable hidden-print" data-spy="affix" style="top:17px;display:none;"  >
        <div class="toc"><ul class="nav"><li class=""><a href="#B10502224-古智斌-OS-HW1" title="B10502224 古智斌 OS　HW1">B10502224 古智斌 OS　HW1</a><ul class="nav"><li class=""><a href="#Part-1" title="Part 1">Part 1</a></li><li class=""><a href="#Part-2" title="Part 2">Part 2</a><ul class="nav"><li class=""><a href="#Chapter-0-Operating-Systems-Interfaces" title="Chapter 0. Operating Systems Interfaces">Chapter 0. Operating Systems Interfaces</a></li><li class=""><a href="#Chapter-1-Operating-Systems-Organization" title="Chapter 1. Operating Systems Organization">Chapter 1. Operating Systems Organization</a></li></ul></li><li class=""><a href="#Part-3" title="Part 3">Part 3</a><ul class="nav"><li class=""><a href="#Chapter-6-File-Systems" title="Chapter 6. File Systems">Chapter 6. File Systems</a></li></ul></li></ul></li></ul></div><div class="toc-menu"><a class="expand-toggle" href="#">Expand all</a><a class="back-to-top" href="#">Back to top</a><a class="go-to-bottom" href="#">Go to bottom</a></div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.1/jquery.min.js" integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8=" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha256-U5ZEeKfGNOja007MMD3YBI0A3OSZOQbeG6z2f2Y0hu8=" crossorigin="anonymous" defer></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gist-embed/2.6.0/gist-embed.min.js" integrity="sha256-KyF2D6xPIJUW5sUDSs93vWyZm+1RzIpKCexxElmxl8g=" crossorigin="anonymous" defer></script>
    <script>
        var markdown = $(".markdown-body");
        //smooth all hash trigger scrolling
        function smoothHashScroll() {
            var hashElements = $("a[href^='#']").toArray();
            for (var i = 0; i < hashElements.length; i++) {
                var element = hashElements[i];
                var $element = $(element);
                var hash = element.hash;
                if (hash) {
                    $element.on('click', function (e) {
                        // store hash
                        var hash = this.hash;
                        if ($(hash).length <= 0) return;
                        // prevent default anchor click behavior
                        e.preventDefault();
                        // animate
                        $('body, html').stop(true, true).animate({
                            scrollTop: $(hash).offset().top
                        }, 100, "linear", function () {
                            // when done, add hash to url
                            // (default click behaviour)
                            window.location.hash = hash;
                        });
                    });
                }
            }
        }

        smoothHashScroll();
        var toc = $('.ui-toc');
        var tocAffix = $('.ui-affix-toc');
        var tocDropdown = $('.ui-toc-dropdown');
        //toc
        tocDropdown.click(function (e) {
            e.stopPropagation();
        });

        var enoughForAffixToc = true;

        function generateScrollspy() {
            $(document.body).scrollspy({
                target: ''
            });
            $(document.body).scrollspy('refresh');
            if (enoughForAffixToc) {
                toc.hide();
                tocAffix.show();
            } else {
                tocAffix.hide();
                toc.show();
            }
            $(document.body).scroll();
        }

        function windowResize() {
            //toc right
            var paddingRight = parseFloat(markdown.css('padding-right'));
            var right = ($(window).width() - (markdown.offset().left + markdown.outerWidth() - paddingRight));
            toc.css('right', right + 'px');
            //affix toc left
            var newbool;
            var rightMargin = (markdown.parent().outerWidth() - markdown.outerWidth()) / 2;
            //for ipad or wider device
            if (rightMargin >= 133) {
                newbool = true;
                var affixLeftMargin = (tocAffix.outerWidth() - tocAffix.width()) / 2;
                var left = markdown.offset().left + markdown.outerWidth() - affixLeftMargin;
                tocAffix.css('left', left + 'px');
            } else {
                newbool = false;
            }
            if (newbool != enoughForAffixToc) {
                enoughForAffixToc = newbool;
                generateScrollspy();
            }
        }
        $(window).resize(function () {
            windowResize();
        });
        $(document).ready(function () {
            windowResize();
            generateScrollspy();
        });

        //remove hash
        function removeHash() {
            window.location.hash = '';
        }

        var backtotop = $('.back-to-top');
        var gotobottom = $('.go-to-bottom');

        backtotop.click(function (e) {
            e.preventDefault();
            e.stopPropagation();
            if (scrollToTop)
                scrollToTop();
            removeHash();
        });
        gotobottom.click(function (e) {
            e.preventDefault();
            e.stopPropagation();
            if (scrollToBottom)
                scrollToBottom();
            removeHash();
        });

        var toggle = $('.expand-toggle');
        var tocExpand = false;

        checkExpandToggle();
        toggle.click(function (e) {
            e.preventDefault();
            e.stopPropagation();
            tocExpand = !tocExpand;
            checkExpandToggle();
        })

        function checkExpandToggle () {
            var toc = $('.ui-toc-dropdown .toc');
            var toggle = $('.expand-toggle');
            if (!tocExpand) {
                toc.removeClass('expand');
                toggle.text('Expand all');
            } else {
                toc.addClass('expand');
                toggle.text('Collapse all');
            }
        }

        function scrollToTop() {
            $('body, html').stop(true, true).animate({
                scrollTop: 0
            }, 100, "linear");
        }

        function scrollToBottom() {
            $('body, html').stop(true, true).animate({
                scrollTop: $(document.body)[0].scrollHeight
            }, 100, "linear");
        }
    </script>
</body>

</html>
